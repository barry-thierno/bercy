## 7.4 Appels asynchrones Yannick

Lâ€™api Javascript Fetch est vraiment simple Ã  utiliser. Il vous suffit dâ€™utiliser la fonction fetch() avec une url pour effectuer une requÃªte, GET par exemple. La librairie fonctionne avec des promesses, on peut donc utiliser then catch et finally.

Nous allons utiliser notre composant <code>FilterableSliceTable</code> pour faire un appel asynchrone.  
Pour la config Proxy, il sâ€™agit juste de mettre le lien du serveur dans le package.json.

Vous retrouvez l'ensemble des services qui vous avez dÃ» rÃ©aliser lors de la formation C# de bercy ici : [Swagger Bercy](https://bercywebapi.azurewebsites.net/swagger/index.html)

Pour avoir les tranches d'imposition par annÃ©e, nous avons besoin de faire un appel au service Slices.

Utilisons comme exemple le composant <code> FilterableSliceTable </code> prÃ©cÃ©demment dÃ©veloppÃ© dans ce dojo.

```jsx
import React, { useState } from 'react';
import { Table } from '@axa-fr/react-toolkit-all';
import { SliceYearSelect } from 'pages/Home/FilterableSliceTable/SliceYearSelect/SliceYearSelect';
import { SliceTableHeader } from 'pages/Home/FilterableSliceTable/SliceTableHeader/SliceTableHeader';
import { SliceTableRow } from 'pages/Home/FilterableSliceTable/SliceTableRow/SliceTableRow';

export const FilterableSliceTable = () => {
  const [selectedYear, setSelectedYear] = useState('2020');
  const selectedTranches = getAllTranches().find(t => t.year === selectedYear)
    .tranches;

  return (
    <section className="af-panel">
      <header className="af-panel__header">
        <SliceYearSelect
          selectedYear={selectedYear}
          setSelectedYear={setSelectedYear}
        />
      </header>
      <div className="af-panel__content">
        <Table className="af-table">
          <SliceTableHeader />
          <Table.Body>
            {selectedTranches.map(({ id, lowBorn, highBorn, rate }) => (
              <SliceTableRow
                key={id}
                lowBorn={lowBorn}
                highBorn={highBorn}
                rate={rate}
              />
            ))}
          </Table.Body>
        </Table>
      </div>
    </section>
  );
};
```

Nous allons supprimer lâ€™appel Ã  la fonction <code> selectedTranches </code> pour le remplacer par la fonction Fetch. Nous connaissons dÃ©jÃ  lâ€™annÃ©e sÃ©lectionnÃ©e, elle se trouve dans la variable <code> selectedYear </code>.

Comme le lien du serveur est dÃ©jÃ  renseignÃ© dans le proxy du package.json, il ne nous reste plus quâ€™Ã  renseigner le nom du service, câ€™est-Ã -dire <code> Slices </code>. Pour rÃ©cupÃ©rer les donnÃ©es, lâ€™appel au service se fera via un GET. Lâ€™envoi de lâ€™annÃ©e sÃ©lectionnÃ©e se fera via un paramÃ¨tre dans lâ€™url.

```jsx
import React, { useState, useEffect } from 'react';
import { Table } from '@axa-fr/react-toolkit-all';
import { SliceYearSelect } from 'pages/Home/FilterableSliceTable/SliceYearSelect/SliceYearSelect';
import { SliceTableHeader } from 'pages/Home/FilterableSliceTable/SliceTableHeader/SliceTableHeader';
import { SliceTableRow } from 'pages/Home/FilterableSliceTable/SliceTableRow/SliceTableRow';

export const FilterableSliceTable = () => {
  const [selectedYear, setSelectedYear] = useState('2020');
  const [selectedTranches, setSelectedTranches] = useState([]);

  useEffect(() => {
    fetch(`/Slices?year=${selectedYear}`)
      .then(response => response.json())
      .then(json => {
        setSelectedTranches(json);
      });
  });

  return (
    <section className="af-panel">
      <header className="af-panel__header">
        <SliceYearSelect
          selectedYear={selectedYear}
          setSelectedYear={setSelectedYear}
        />
      </header>
      <div className="af-panel__content">
        <Table className="af-table">
          <SliceTableHeader />
          <Table.Body>
            {selectedTranches.map(({ id, lowBorn, highBorn, rate }) => (
              <SliceTableRow
                key={id}
                lowBorn={lowBorn}
                highBorn={highBorn}
                rate={rate}
              />
            ))}
          </Table.Body>
        </Table>
      </div>
    </section>
  );
};
```

Mais avec cette mÃ©thode il y aura deux problÃ¨mes :

- Cas du re-render avec un autre composant :
  Votre application chargÃ©e, le <code> useEffect </code> exÃ©cutera la fonction et appellera le web service. DÃ¨s la fonction exÃ©cutÃ©e, vous continuerez Ã  utiliser votre application. Quand par exemple vous allez cliquer sur le bouton <code> calculer </code>, vous allez mettre Ã  jour votre <code> state </code>, cela va provoquer un re-render de lâ€™application et ainsi appeler Ã  nouveau le service.

- Cas de lâ€™appel infini si on utilise un setter dans useEffect :
  Une fois votre application chargÃ©e, le <code> useEffect </code> va exÃ©cuter la fonction qui appellera le web service. Sâ€™il rÃ©pond positivement, vous pouvez appeler votre setter pour mettre Ã  jour les donnÃ©es, dans notre cas, les tranches et leur taux dâ€™imposition. Mais en exÃ©cutant le setter, il va re-render votre composant qui rÃ©exÃ©cutera la mÃªme fonction dans le UseEffect â€¦ vous lâ€™aurez compris cela va faire une boucle infinie.

Pour remÃ©dier Ã  ce problÃ¨me, dans les deux cas, il faut utiliser le deuxiÃ¨me paramÃ¨tre tableau de dÃ©pendances dans le <code> useEffect </code>. Cela va permettre d'exÃ©cuter la fonction, uniquement si une des valeurs du tableau a Ã©tÃ© modifiÃ©e depuis lâ€™appel prÃ©cÃ©dent.

```jsx
useEffect(() => {
  fetch(`/Slices?year=${selectedYear}`)
    .then(response => response.json())
    .then(json => {
      setSelectedTranches(json);
    });
}, [selectedYear]);
```

Dans notre cas, si la valeur de lâ€™annÃ©e sÃ©lectionnÃ©e ne change pas, alors le service ne sera pas rappelÃ©. Assez de thÃ©orie, nous allons passer Ã  quelques exercices ğŸ˜‰

**:weight_lifting_man: Exercice 7.4.1 : Appeler le service TaxComputer**

Allez directement sur [Swagger Bercy](https://bercywebapi.azurewebsites.net/swagger/index.html). Nous retrouvons le service <code>TaxComputer</code> qui va nous permettre de calculer le montant mais aussi le taux dâ€™imposition.

Vous allez devoir mettre en place cet appel dans le composant <code> TaxComputationForm </code>.
Pour vous aider voici un exemple de code qui permet dâ€™appeler un service en POST .

```jsx
fetch('/NomDuService', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(/* votre input ici */),
})
  .then(response => response.json())
  .then(json => {
    /* votre code */
  });
```

Dans le premier paramÃ¨tre, vous devrez mettre le nom du service, et dans le second quelques paramÃ¨tres :

- Method : la mÃ©thode que vous voulez utilisez, GET, POST, PUT, DELETEâ€¦.
- Headers : quelques paramÃ¨tres plus techniques mais importants
- Body : lâ€™objet que vous voulez envoyer au service

Dans notre exercice, le service se nomme <code> TaxComputer </code>, le header reste le mÃªme que dans lâ€™exemple, et le body devra recevoir un objet comme ceci :

```jsx
    const input = {
        wage: <code> le salaire </code>,
        year: <code> annÃ©e </code>,
        taxHouseholdComposition: {
        nbAdults: â€œnombre adulteâ€,
        nbChildren: â€œnombre enfantâ€,
        },
    };
```

On pourra rÃ©cupÃ©rer la rÃ©ponse du service dans le bloc then() et les donnÃ©es grÃ¢ce Ã  la variable response. Dans cette derniÃ¨re vous trouverez les donnÃ©es de la requÃªte HTTP, le header, le body et les paramÃ¨tres.

Vous devrez effectuer la mise Ã  jour des donnÃ©es avec votre setter dans le second bloc <code> Then </code>.
Attention, le service ne renvoie que le montant de lâ€™impÃ´t <code> amount </code> et le taux dâ€™imposition <code> marginalTaxRate </code>.

Pour mettre Ã  jour le nombre de parts, vous devez utiliser une fonction comme vous le rÃ©alisiez auparavant avec le computeTaxeService. Ici vous devez utiliser la fonction <code> calculNbPartsService </code>, elle reÃ§oit deux paramÃ¨tres : le nombre dâ€™adultes en premier et le nombre dâ€™enfants en second. Respectez bien lâ€™ordre, celui-ci est trÃ¨s importantğŸ˜‰

**:weight_lifting_man: Exercice 7.4.2 : Mettre en place un message dâ€™erreur**

VoilÃ , vous avez appeler le service et mettre Ã  jour les donnÃ©es dans le composant !!! Mais que se passerait-il si le service renvoyait une erreur ?

Dans la plupart des applications modernes, on utilise un message dâ€™alerte pour avertir lâ€™utilisateur sâ€™il manque des donnÃ©es dans le formulaire par exemple ou si le service est KO et nous renvoie une erreur.

Lâ€™exercice est simple, vous allez mettre en place un message dâ€™information quand le service est en erreur. Pour ce faire, mettez en place le composant <code> Alert </code> du toolkit Axa dans le composant <code> TaxComputationForm </code>

```jsx
<Alert
  classModifier="error"
  title="une erreur est survenue, veuillez vÃ©rifier les donnÃ©es saisies."
/>
```

Attention Ã  ne pas oublier lâ€™import dans lâ€™entÃªte du composant. Pour afficher ou non le message dâ€™erreur, il faudra crÃ©er une variable de type booleen ainsi que son setter.

Mais comment rÃ©cupÃ©rer une erreur ? Si pour une raison X la fonction fetch retourne une erreur, on peut la rÃ©cupÃ©rer avec le bloc catch(). Dans cette fonction on obtient une variable, par exemple <code> error </code> qui permet dâ€™obtenir des informations.

```jsx
      .catch(() => {
        /* votre code */
      })
```

Allez câ€™est parti, Ã  vos claviers ! ğŸ˜‰

**:weight_lifting_man: Exercice 7.4.3 : Et â€¦. ce nâ€™est pas fini !**

<code>Then(), Catch et finally()</code> .. Et oui, il reste encore un cas que nous allons utiliser. Quand lâ€™utilisateur va cliquer sur le bouton "calculer", on appelle un service.

Mais visuellement pour quâ€™il comprenne bien que le calcul est en cours, on affiche un spinner. Un cercle qui tourne, qui sâ€™affiche en pleine page et qui bloque toutes autres actions de lâ€™utilisateur. Et oui cela a aussi une fonction pratique.

Dans le toolkit Axa, il existe un loader, voici son code :

```jsx
      .catch(() => {
        /* votre code */
      })
```

Nâ€™oubliez pas dâ€™ajouter ce code CSS !!!

```css
.af-loader.af-loader--spinner.af-loader-on {
  position: fixed !important;
  z-index: 100;
}
.af-loader {
  min-height: auto !important;
}
```

Son mode de fonctionnent nâ€™est pas des plus simples mais je vais tenter de vous lâ€™expliquer.
Alors pour afficher le spinner sur votre page, la props <code>mode</code> du composant doit Ãªtre â€˜Getâ€™, â€˜Postâ€™ etc â€¦. Et pour ne plus lâ€™afficher, â€˜noneâ€™. Il faudra donc crÃ©er une variable avec son setter, la positionner avant le fetch avec le mode â€˜Postâ€™, et dans le bloc finally avec le <code>mode</code> â€˜noneâ€™.

Je compte sur vous, Ã  vos claviers ğŸ˜Š
