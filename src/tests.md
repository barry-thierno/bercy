<h1>Tester ses composants React</h1>

_Par Olivier YOUF_ Texte original sur [Component Testings](https://github.com/youf-olivier/componentsTesting)

- [Analyse statique](#analyse-statique)
  - [EsLint](#eslint)
  - [Prettier](#prettier)
  - [Plugins](#plugins)
  - [Typescript](#typescript)
- [Tests unitaires](#tests-unitaires)
  - [Jest](#jest)
    - [Les matchers](#les-matchers)
    - [Mocker les fonctions avec Jest](#mocker-les-fonctions-avec-jest)
- [Tests d'int√©gration](#tests-dint√©gration)
  - [Le test d'int√©gration](#le-test-dint√©gration)
  - [Installation](#installation)
  - [Tester la vue](#tester-la-vue)
  - [Tester strictement la vue : les requ√™tes](#tester-strictement-la-vue--les-requ√™tes)
  - [Faciliter les assertions : Jest Dom](#faciliter-les-assertions--jest-dom)
  - [Tester les interactions : User Event](#tester-les-interactions--user-event)
  - [Tester les rendus asynchrones : waitFor](#tester-les-rendus-asynchrones--waitfor)
- [Pour aller plus loin : Partie 2](#pour-aller-plus-loin--partie-2)

Avoir un code qui marche c'est bien, mais √™tre s√ªr de son bon fonctionnement et de sa p√©rennit√© c'est mieux. C'est ce qu'on appelle la qualit√©. Et pour cela il existe un panel d'outils que nous allons voir ensemble.

## Comment tester son application

Un projet React est un ensemble complet et complexe de composants, de fonctions et de patterns en tous genres. Nous allons voir tout au long de ce chapitre les diff√©rents outils qui sont √† notre disposition pour tester son application

<img src="./images/testTrophy.png" alt="Tests Trophy" style="zoom: 50%;" />

> R√©partition id√©ale des tests dans un projet.

Voyons cela ensemble, en remontant le troph√©e, nous avons :

- **La v√©rification statique :** grace aux outils tels que *Eslint* ou *Prettier* nous allons faire une premi√®re v√©rification statique de code.
- **Les tests unitaires :** Nous allons pouvoir tester des pans de code javascript afin de v√©rifier que le code fait ce qu'on attend de lui.
- **Les tests d'int√©gration :** Ici nous cherchons a v√©rifier que les composants fonctionnent correctement entre eux.
- **Les tests end to end :** Ce type de test, bien plus couteux en temps, va tester l'application de bout en bout.

Durant cette s√©rie d'exercices nous allons nous concentrer sur les 3 premiers √©l√©ments. Les tests End to End pourront √™tre vus √† ult√©rieurement.

# Analyse statique

Avant de tester quoi que ce soit, nous pouvons d√©j√† analyser statiquement son code. Cette pratique est une aide qui va permettre de d√©grossir tout ce qui erreur de frappe, ou qualit√© de base du code. On va ainsi √©liminer toute une cat√©gorie de bugs √† l'aide de quelques outils de base.

## EsLint 

<img src="./image/../images/eslint.png" style="zoom:25%;" />

Eslint est un *linter*, un utilitaire qui va analyser le code de mani√®re statique pour y d√©celer tout un ensemble de probl√®mes √† partir de r√®gles pr√©d√©finies. On peut choisir d'ajouter un linter pour le javascript mais √©galement pour React.

De base il est pr√©sent dans les solutions g√©n√©r√©es par Create React App. Le cas √©ch√©ant, rien de plus simple, il suffit de se laisser guider par le CLI :

```
npx eslint --init
```

ensuite on peut le lancer localement,

```
npx eslint .
```

ou, mieux, configurer un script dans le package.json

```json
 "scripts": {
     ...
    "lint": "eslint --ignore-path .gitignore .",
  },
```

Afin d'√©viter de scanner les node_modules ou tout autre fichier g√©n√©r√©, nous indiquons que nous ne voulons scanner que ce qui sera envoy√© sur le repo distant. Pour cela nous nous appuyons sur le fichier gitignore.

Vous pourrez ensuite √† loisir modifier les r√®gles, en importer des nouvelles (plugins) ou appliquer des templates (extends)

‚ùóÔ∏è N'oubliez pas d'ajouter une configuration afin de scanner les bons fichiers ‚ùóÔ∏è

```json
"eslintConfig": {
  "extends": [
    "react-app",
    "react-app/jest"
  ],
  "overrides": [{"files": ["**/*.js?(x)"]}]
}
```

## Prettier 

<img src="./images/prettier.png" style="zoom:25%;" />

*Prettier*, √† l'instar d'*EsLint*, va venir √©galement analyser le code mais en se focalisant sur le formatage. Il va venir regarder l'indentation, le placement des parenth√®ses, les virgules, les espace etc. C'est un outil √† ne pas n√©gliger car il permettra d'avoir, au sein d'une √©quipe, un code homog√®ne. De plus, avoir des r√®gles partag√©es et automatiques permettra de ne plus se pr√©occuper de la mise en page et de supprimer ces modifications qui polluent les Pull Requests.

Attention cependant, prettier et EsLint peuvent entrer en conflit, il faudra donc ajouter le plugin prettier d'eslint qui va venir simplement d√©sactiver les r√®gles esLint qui peuvent entrer en conflit avec Prettier.

Rien de plus simple ici aussi.

```
npm install --save-dev prettier
```

Puis ensuite configurer la tache

```json
"scripts": {
    ...
    "lint": "eslint --ignore-path .gitignore .",
    "format": "prettier --ignore-path .gitignore --write \"**/*.+(js|jsx|json)\""
  }
```

De la m√™me mani√®re nous ignorons les fichiers du gitignore pour ne se concentrer que sur les fichiers √† pousser.

## Plugins

Afin de fluidifier leur utilisation, il existe des extensions sur la plupart des √©diteurs de code, qui permettra de voir les erreurs esLint et de formater les fichiers √† la sauvegarde.

<img src="./images/eslintExemple.png" style="zoom: 33%;" />

## Typescript

Avec TypeScript nous allons atteindre un niveau suppl√©mentaire de validation statique. Avec la mise en place des types, le code va pouvoir √™tre v√©rifi√© √† la compilation √† l'aide de la validation de type.

üèãÔ∏è‚Äç‚ôÄÔ∏è Pas d'exercice ici, le Typescript est un sujet √† part enti√®re.

# Tests unitaires

Les tests unitaires sont connus de tous et ne n√©cessitent pas de connaissance particuli√®re. Il faut cependant faire attention √† plusieurs points, pour ne pas se perdre dans la pratique. Un test unitaire sert a tester du code isol√© et ind√©pendant. Pour cela il est important de faire attention √† :

- **Couverture :** Ne pas chercher 100% de couverture de code avec les Tests unitaires, c'est contre productif et fait perdre un temps infini
- **Que tester :** les tests unitaires vont vous servir √† tester des fonctions pures, des services, du code isol√©.

Voici cependant les outils √† connaitre, et qui vont nous servir pour la suite.

## Jest

Jest est devenu l'outil incontournable et pr√©conis√© pour tester son application JS. Il est de base fourni par Create React App, nous n'allons pas nous attarder sur son installation. Pour √©crire son premier test nous devons juste suivre la convention de nommage (.spec, .test ou dans un r√©pertoire "\_\_test\_\_")

Reste ensuite √† lancer la commande

```
npm run test
```

Les tests vont √™tre lanc√©s en mode "watch", c'est √† dire qu'il se relanceront automatiquement d√®s qu'une modification de fichier sera d√©tect√©e.

Pour √©crire un test, il y a toujours les 3 parties que vous connaissez sans doutes d√©j√† : **ARRANGE, ACT, ASSERT.**

Le test est √©crit √† l'int√©rieur d'une fonction contenu dans un bloc it (ou test) que l'on peut lui m√™me int√©grer dans un bloc describe (afin de faire des regroupements logiques)

```javascript
describe("Mon jeu de tests", ()=>{
  it("1+2 devrait retourner 3", ()=>{
    // arrange and act
    const result = 1+2;
    // assert 
    expect(result).toEqual(2);
  })
})
```

### Les matchers

Pour √©crire un test, il y a toujours les 3 parties que vous connaissez sans doutes d√©j√† : **ARRANGE, ACT, ASSERT.** Avec la fonction **expect**, nous allons pouvoir acc√©der aux matchers pour mettre en place les assertions qui permettront de valider le test. Voici une liste des matchers les plus communs : 

- **toEqual** : le plus commun des plus communs. On v√©rifie une √©galit√© de valeur. Sur une object, il effectue une comparaison r√©cursive.
- **toBe** : v√©rifie une √©galit√© au niveau de la r√©f√©rence. 
- **toBeFalsy/toBeTruthy**
- **toBeNull/toBeUndefined**

En chainant le expect avec le not nous pouvons indiquer que nous voulons v√©rifier le r√©sultat inverse. Par exemple :

```javascript
// true 
expect(1+2).toEqual(3);
// true
expect(2+2).not.toEqual(3);
```

> **üèãÔ∏è‚Äç‚ôÄÔ∏è Ouvrez la solution et √©crivez les tests du [premier exercice Jest](https://codesandbox.io/s/bercy-tests-2gy1w?file=/src/shared/taxComputer.helper.spec.js)**

### Mocker les fonctions avec Jest

Il arrive que nous ayons √† tester des fonctions faisant appel √† d'autres fonctions. Ces fonctions, inject√©es ou import√©es directement vont poser une probl√©matique : 

- Elles rendent la fonction impure et peuvent rendre le test instable dans la dur√©e (ajouter un math.Random et le test ne marche plus tout le temps)
- On veut pouvoir v√©rifier que l'appel a √©t√© fait, ou non, dans de bonnes conditions.

Si la fonction est interne et qu'elle est pure, il n'est pas n√©cessaire de la tester √† part ou de la mocker. Sauf si sa complexit√© et des tests s√©par√©s permettent une meilleure lisibilit√©, ce genre de fonctions est test√© au sein m√™me de la fonction principale.

Regardons cet exemple.

```javascript
const calcul = (a, b, fn) => {
  const c = 10*a;
  const d = 10*b;
  return fn(c, d);
}
```

Ici nous allons v√©rifier que la fonction *fn* est appel√©e avec les bons param√®tres et qu'elle nous retourne le bon r√©sultat.

Pour cela nous allons remplacer la fonction existante :

```javascript
const fn = jest.fn((a, b)=>a + b);
```

Ici nous avons remplac√© une fonction simple par une fonction mock√©e renvoyant une simple addition. 

Une fois la fonction principale appel√©e, nous allons pouvoir faire nos v√©rifications. Pour cela nous allons pouvoir utiliser des matchers sp√©cifiques. Voici les principaux.

```javascript
it("effectue un appel vers fn", () => {
  // Arrange
  const fn = jest.fn((a, b)=>a + b);
  
  // Act
  const result = calcul(3, 5, fn);
  
  //Assert 
  expect(result).toEqual(70);
  
  expect(fn).toHaveBeenCalled();
  expect(fn).toHaveBeenCalledTimes(1);
  expect(fn).toHaveBeenCalledWith(30, 50);
  expect(fn).toHaveBeenNthCalledWith(1, 30, 50);
})
```

Attention, des fonctions asynchrone ne renvoient pas de r√©sultat, mais des promesses de r√©sultats :
```javascript
const asyncFnMock = jest.fn(()=> Promise.resolve("result"));
```

> üèãÔ∏è‚Äç‚ôÄÔ∏è **Ouvrez la solution et √©crivez les tests du [deuxi√®me exercice Jest](https://codesandbox.io/s/bercy-tests-2gy1w?file=/src/pages/Home/FilterableSliceTable/FilterableSliceTable.s.spec.js) du chapitre Jest**

<img src="./images/jalon.jpg" style="zoom:33%;" />

# Tests d'int√©gration

Tester une fonction pure qui retourne un r√©sultat simple est facile √† appr√©hender et maitriser. Cependant en React nous allons devoir aller un peu plus loin. En tant qu'interface utilisateur, pour tester le composant, nous allons tester son comportement. Pour cela nous allons utiliser [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/). 

## Le test d'int√©gration

Tout d'abord nous devons diff√©rencier le test d'int√©gration du test unitaire.

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The more your tests resemble the way your software is used, the more confidence they can give you.</p>&mdash; Kent C. Dodds üöÄ (@kentcdodds) <a href="https://twitter.com/kentcdodds/status/977018512689455106?ref_src=twsrc%5Etfw">March 23, 2018</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

La philosophie est l√†. Le test d'int√©gration c'est :

- ü§úüèª Tester efficacement qu‚Äôun composant fait exactement ce qu‚Äôattend l‚Äôutilisateur. **Plus que couvrir du code, nous allons couvrir les cas d‚Äôutilisations**. Nous allons lister les sc√©narios et les tester.
- üí® √ätre **r√©siliant √† la refactorisation** qui est par d√©finition une modification du code sans impact sur les fonctionnalit√©s.
- ü§ù Augmenter sensiblement la confiance dans ce qui est produit. Une fois le composant s√©curis√© par ses tests, nous sommes confiant sur la fonctionnalit√©.
- üí∞ Plus couteux (un peu) qu‚Äôun test unitaire mais moins que le test End-To-End

> Il faut user et abuser des tests d'int√©gration par rapport aux tests unitaire.

![](./images/inteVsUnit.gif)

> - ‚úÖ La porte 1 s'ouvre
> - ‚úÖ Les portiques s'ouvrent
> - Tests : <span style="color:green">**2 passed**</span>, 2 total

## Installation

React Testing library n‚Äôest pas seulement une librairie, c‚Äôest un vrai √©cosyst√®me. Nous allons voir √† travers nos couches, les diff√©rentes fa√ßons de couvrir notre application.

```
npm install --save-dev @testing-library/react
```

C‚Äôest la base, ce qui va nous permettre d‚Äôutiliser le render de composant.

```
npm install --save-dev @testing-library/user-event
```

Cette partie va nous permettre de simuler les actions de l‚Äôutilisateur.

```
npm install --save-dev @testing-library/jest-dom
```

Ici c‚Äôest plus une boite √† outil, vraiment tr√®s utile. Elle va venir enrichir les fonctions disponibles pour valider nos tests.

```
npm install --save-dev @testing-library/react-hooks react-test-renderer
```

Le package react hooks sera utile uniquement pour tester des hooks r√©utilisables. Pour les hooks des containers, nous les testerons directement au sein de leur composant avec React Testing Library.

Ce package n√©cessite react-test-renderer qu‚Äôon doit installer en plus.
Une fois ces librairies install√©es, en fonction de vos besoins, nous pouvons faire une toute petite configuration dans le fichier setupTests.js

```
import '@testing-library/jest-dom';
```

Cet import, n√©cessaire pour utiliser les extensions de Jest-dom, sera de ce fait effectu√© pour chaque test.

---

‚ùóÔ∏è _Si vous utilisez React Script (Create React App) ant√©rieur √† la version 4, ce dernier embarque la version de Jest 24. Malheureusement la librairie de tests n√©cessite Jest 26 (pour l‚Äôutilisation de waitFor par exemple). De ce fait vous devez embarquer jest-environment-jsdom-sixteen_

```
npm install --save-dev jest-environment-jsdom-sixteen
```

Puis l‚Äôajouter dans les scripts de lancement de tests dans votre package.json :

```json
"scripts": {
...,
  "test": "react-scripts test --env=jest-environment-jsdom-sixteen"
...
}
```

## Tester la vue

La vue va se tester en deux √©tapes.

Dans un premier temps nous allons poser un filet de s√©curit√© pour alerter le d√©veloppeur en cas de modification : **Le snapshot**.

Le snapshot est un sujet qui d√©chaine les foules. Il est pourtant assez mineur et ne repr√©sente qu‚Äôune faible partie de la pratique. Il a juste un r√¥le d‚Äôavertissement. Sur une vue simple il sera suffisant, sur une vue plus sp√©cifique, nous le verrons ensuite, il devra √™tre accompagn√©.

```javascript
it('renders correctly', () => {
  const { asFragment } = render(<User user={user} />);
  expect(asFragment()).toMatchSnapshot();
});
```

Diff√©rence asFragment / container :

- **Container** : Contient le DOM et est **mutable**
- **AsFragment** : Renvoi un DocumentFragment qui est un objet minimal et **immutable**

> **üèãÔ∏è‚Äç‚ôÄÔ∏è Basez vous sur les tests existants pour tester les vues simples et sans logique. ( [RTL Exercice 1](https://codesandbox.io/s/bercy-tests-2gy1w?file=/src/pages/Home/FilterableSliceTable/SliceTableRow/SliceTableRow.spec.js))**

Ce qui est bien avec le JSX c‚Äôest que nous pouvons poser, au besoin des conditions, des mappers, des boucles etc.

Il s'agit de logique et donc afin de v√©rifier et tester correctement ces √©l√©ments nous devons donc accompagner le snapshot. La lecture du test doit indiquer ce que nous v√©rifions, et le snapshot ne le permet pas.

Pour cela nous allons devoir explorer le contenu du rendu √† travers les **requ√™tes**.

## Tester strictement la vue : les requ√™tes

Cette requ√™te est compos√©e de deux choses : le comment et le quoi.

Le comment est la premi√®re partie. Nous allons indiquer comment r√©cup√©rer ce que nous voulons chercher. Nous avons :

- **get[All]By** : Ici nous voulons r√©cup√©rer un √©l√©ment. Si la requ√™te √©choue si aucun ou plusieurs √©l√©ments sont trouv√©s. Si nous ajoutons All nous indiquons que nous voulons tous les √©l√©ments trouv√©s qui seront renvoy√©s sous forme de liste.
- **query[All]By** : Fonctionne de la m√™me fa√ßon que le get, sauf que s‚Äôil ne trouve pas d‚Äô√©l√©ment, il renverra null. Utile pour tester la non existence d‚Äôun √©l√©ment.
- **find[All]By** : Fonctionne de la m√™me fa√ßon que le get, √† la diff√©rence qu‚Äôil va renvoyer une promesse qui sera r√©solue une fois l‚Äô√©l√©ment trouv√© ou le timeout pass√©. Outil tout d√©sign√© pour tester un appel de service par exemple.

Le quoi va permettre de cibler l‚Äô√©l√©ment. Pour cela il y a une multitude de requ√™tes. Nous allons en voir les principales, par leur ordre d‚Äôimportance.

- **ByRole :** C‚Äôest LA requ√™te a privil√©gier. Ici nous allons acc√©der √† l‚Äô√©l√©ment par son r√¥le (bouton, champ, liste‚Ä¶) souvent accompagn√© de son name. Cette requ√™te se base sur l‚Äôaccessibilit√© de l‚Äô√©l√©ment. Pour plus de d√©tails vous pouvez vous reporter √† mon pr√©c√©dent article sur l‚Äôaccessibilit√©.

```javascript
// R√©cup√©ration d'un bouton valider
screen.getByRole('button', { name: 'valider' });
// R√©cup√©ration d'une liste d'item
screen.getByRole('listitem', { name: 'liste des utilisateurs' });
```

- **ByLabelText :** C‚Äôest la m√©thode √† privil√©gier pour r√©cup√©rer des champs de formulaire.

```javascript
// R√©cup√©ration du champ de formulaire dont le label est pr√©nom
screen.getByLabelText(/pr√©nom/i);
```

- **ByText :** Nous allons ici pouvoir r√©cup√©rer un √©l√©ment en g√©n√©ral non interactif, par rapport √† son contenu, par exemple une div ou un span.

```javascript
// R√©cup√©ration du message quand aucun utilisateur n'est affich√©
screen.getByText(/aucun utilisateur trouv√©/i);
```

Mais √©galement getByAltText, getByTitle, etc.

Il y a √©galement deux requ√™tes √† connaitre mais √† n'utiliser qu'en cas de dernier recours :

Le query selector 

```javascript
const {container} = render(<Component/>);
container.querySelector(".myclass");
```

ByTestId

```javascript
// R√©cup√©ration d'un √©l√©ment par son attribut testId
render(
   <div>
      <span data-testid="superspan">‚òπÔ∏è</span>
   </div>
);
screen.getByTestId("superspan");
```

## Faciliter les assertions : Jest Dom

Avec Jest Dom nous allons pouvoir faire des assertions explicites

- toBeDisabled
- toBeEnabled
- toBeEmpty
- toBeEmptyDOMElement
- toBeInTheDocument
- toBeInvalid
- toBeRequired
- toBeValid
- toBeVisible
- toContainElement
- toContainHTML
- toHaveAttribute
- toHaveClass
- toHaveFocus
- toHaveFormValues
- toHaveStyle
- toHaveTextContent
- toHaveValue
- toHaveDisplayValue
- toBeChecked
- toBePartiallyChecked
- toHaveDescription

> **üèãÔ∏è‚Äç‚ôÄÔ∏è Servez vous de ces nouveaux outils afin de passer sur l'exercice suivant ([RTL exercice 2](https://codesandbox.io/s/bercy-tests-2gy1w?file=/src/pages/Home/TaxResult/TaxResult.spec.js))**

<img src="./images/jalon.jpg" style="zoom:33%;" />

## Tester les interactions : User Event

UserEvent est un package de la librairie qui va faciliter l'interaction utilisateur. Elle est relativement simple et se base sur deux fonctions :

- **type** : Pour simuler le clavier
- **click** : Pour simuler la souris.

```javascript
// Je remplis un formulaire et je le valide.
const input = screen.getByLabelText(/Compte Github/i);
const button = screen.getByRole('button', { name: /Rechercher/ });

await userEvent.type(input, 'gaearon');
await userEvent.click(button);
```

Il en existe d'autre moins courantes : https://github.com/testing-library/user-event#api

> **üèãÔ∏è‚Äç‚ôÄÔ∏è Simulez la manipulation d'un champs avec cette nouvelle librairie ([RTL exercice 3](https://codesandbox.io/s/bercy-tests-2gy1w?file=/src/pages/Home/FilterableSliceTable/SliceYearSelect/SliceYearSelect.spec.js))**

## Tester les rendus asynchrones : waitFor

La derni√®re section que nous allons aborder est sur la gestion du contenu asynchrone. Je vous propose de rester dans la simplicit√©. Ici on va demander au test d'attendre. Tout simplement.

Deux fonctions vont nous aider, la principale est d'attendre sp√©cifiquement que quelque chose se produise :

```javascript
await waitFor(() => expect(screen.queryByRole('alert', { name: 'loader' })).not.toBeInTheDocument());
```

L'autre est plus sp√©cifique et vous servira nettement moins, mais sera r√©guli√®rement necessaire

```javascript
await waitForElementToBeRemoved(screen.queryByRole('alert', { name: 'loader' }));
```

Les plus attentifs auront remarqu√© que les deux fonctions font la m√™me chose. Mais vous serez d'accord que la seconde est plus explicite. S'il y a une chose √† retenir de toute cette partie c'est bien cela :

> **The more your tests resemble the way your software is used, the more confidence they can give you.**

> **üèãÔ∏è‚Äç‚ôÄÔ∏è Tester la r√©cup√©ration d'une requ√™te avec UserEvent et le waitFor ([RTL Exercice 4](https://codesandbox.io/s/bercy-tests-2gy1w?file=/src/pages/Home/FilterableSliceTable/FilterableSliceTable.spec.js))**

<img src="./images/jalon.jpg" style="zoom:33%;" />

> **üèãÔ∏è‚Äç‚ôÄÔ∏è vous etes autonome pour un composant complet ([RTL Exercice 5](https://codesandbox.io/s/bercy-tests-2gy1w?file=/src/pages/Home/TaxComputationForm/TaxComputationForm.spec.js))**

<img src="./images/jalon.jpg" style="zoom:33%;" />

# Pour aller plus loin : Partie 2

Nous avons ici aborder les mani√®re basqieu de tester son application, dans un dojo test avanc√©s, je vous proposerai d'aborder les sujets suivants :

- Automatiser et industrialiser les linter
- React Testing Library Avanc√©s :
  - Tester les providers
  - Tester les hooks
  - Tester le router
  - Tester Redux
  - Mocker l'api avec MOck Service Worker
